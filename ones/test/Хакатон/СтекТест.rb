require 'test_helper'
module HackathonTest
  module QСтекТест
    module QОбщиеТесты
      shared_examples_for 'ОбщийМодуль.Стек' do
        describe 'Функция Пустой' do
          it 'Возвращает Истина когда в массиве стек нет элементов' do
            стекСтруктура.стек.Count.must_equal 0
            стек.Пустой(стекСтруктура).must_equal true
          end

          it 'Возвращает Ложь когда в массиве стек есть элементы' do
            стекСтруктура.стек << 1
            стек.Пустой(стекСтруктура).must_equal false
          end
        end

        describe 'Функция Снять' do
          it 'Берет первый элемент из массива стек и удаляет его из массива' do
            3.times do |i|
              стекСтруктура.стек << i
            end

            стекСтруктура.стек.to_a.must_equal [0,1,2]
            стек.Снять(стекСтруктура).must_equal 0
            стек.Снять(стекСтруктура).must_equal 1
            стек.Снять(стекСтруктура).must_equal 2
            стекСтруктура.стек.to_a.must_equal []
          end

          it 'Когда стек пустой кидает исключение' do
            стекСтруктура.стек.to_a.must_equal []
            e = proc {
              стек.Снять(стекСтруктура)
            }.must_raise WIN32OLERuntimeError
            e.message.must_match /ОшибкаСтекПустой/i
          end
        end

        describe 'Функция Поместить' do
          it 'Помещает значение на голову массива стек' do
            стекСтруктура.Стек.to_a.must_equal []
            стек.Поместить(стекСтруктура, 3)
            стекСтруктура.Стек.to_a.must_equal [3]
            стек.Поместить(стекСтруктура, 2)
            стекСтруктура.Стек.to_a.must_equal [2, 3]
          end

          it 'Возвращает помещаемое занчение' do
            стек.Поместить(стекСтруктура, 42).must_equal 42
          end
        end
      end
    end

    describe 'ОбщийМодуль.Стек' do
      like_rubify_runtime Runtimes::Thick

      describe 'Неограниченный стек' do
        it_behaves_like 'ОбщийМодуль.Стек'

        def стекСтруктура
          @стекСтруктура ||= стек.СтекСоздать
        end

        describe 'Функция ЭтоОграниченныйСтек' do
          it 'Вернет Ложь когда стек не ограниченный' do
            стек.ЭтоОграниченныйСтек(стекСтруктура).must_equal false
          end
        end

        describe 'функция Полный' do
          it 'Возвращает Ложь когда стек не ограниченный' do
            стек.Полный(стекСтруктура).must_equal false
          end
        end
      end

      describe 'Ограниченный стек' do
        it_behaves_like 'ОбщийМодуль.Стек'

        def ожидаемыйРазмер
          3
        end

        def стекСтруктура
          @стекСтруктура ||= стек.СтекОграниченныйСоздать(ожидаемыйРазмер)
        end

        it 'Фабричный метод СтекОграниченныйСоздать' do
          стек.СтекОграниченныйСоздать(10).Емкость.must_equal 10
        end

        describe 'Функция Поместить' do
          it 'Кидает исключение когда стек полный' do
            ожидаемыйРазмер.times do |i|
              стекСтруктура.Стек << i
            end
            стек.Полный(стекСтруктура).must_equal true
            e = proc {
              стек.Поместить(стекСтруктура, 10)
            }.must_raise WIN32OLERuntimeError
            e.message.must_match /ОшибкаСтекПолный/i
          end
        end

        describe 'Функция ЭтоОграниченныйСтек' do
          it 'Вернет Истна когда стек ограниченный' do
            стек.ЭтоОграниченныйСтек(стекСтруктура).must_equal true
          end
        end

        describe 'функция Полный' do
          it 'Возвращает Ложь когда колич. элем. в массиве Стек меньше емкости' do
            стекСтруктура.Стек.Количество().must_be :<, стекСтруктура.Емкость
            стек.Полный(стекСтруктура).must_equal false
          end

          it 'Возвращает Истина когда колич. элем. в массиве Стек равно емкости' do
            ожидаемыйРазмер.times do |i|
              стекСтруктура.Стек << i
            end
            стекСтруктура.Стек.Количество().must_be :==, стекСтруктура.Емкость
            стек.Полный(стекСтруктура).must_equal true
          end
        end
      end
    end
  end
end

